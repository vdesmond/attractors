{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"attractors in chaos, emerges beauty <p>A package for simulation and visualization of strange attractors.</p> <p> </p> <p> </p> <ul> <li>Creator's note</li> <li>Core Features</li> </ul>"},{"location":"#creators-note","title":"Creator's note","text":"<p>In the realm where mathematics transcends into art, strange attractors emerge as mesmerizing patterns that dance on the edge of chaos. This package is an attempt to visualize that: bringing rigorous numerical computation and stunning visualization that brings these mathematical marvels to life.</p> <p>Born from a fascination with dynamical systems, I made the package attractors to provide an elegant interface to explore, simulate, and visualize the haunting beauty of chaotic systems. From the iconic spirals of the Lorenz attractor to the ethereal forms of lesser-known systems, each visualization tells a story of order emerging from chaos.</p> <p>Now in its completely reimagined second iteration, attractors is now powered by Numba-accelerated computations and a modular architecture that supports extension in creating more solvers, systems, themes and visualizers while keeping the dependencies lean and code clean, typed and tested. In short, its artistic soul is kept as is, while I ported it to modern software design: clean, fast, and endlessly adaptable.</p> <p>I hope you enjoy this package as much as I enjoyed creating it!</p> <p>Warning</p> <p>The version 2.x of attractors is a complete rewrite and is not backward compatible with the previous versions. Especially the API has been completely revamped, and the CLI support has been removed (though it might be added back in the future). If you are looking for the older version, you can find it in the v1.x branch</p>"},{"location":"#core-features","title":"Core Features","text":"<ul> <li>A curated collection of 20+ strange attractors including classics and rare gems</li> <li>High-performance numerical solving using Numba-accelerated Runge-Kutta solvers</li> <li>Stunning visualizations with various themes and color mappings</li> <li>Modular design that welcomes extensions and experimentation</li> </ul> <p>Check out the quickstart guide to get started with attractors!</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#attractors.Solver","title":"<code>attractors.Solver</code>  <code>dataclass</code>","text":"<p>Data class representing a numerical ODE solver with JIT compilation support.</p> <p>Attributes:</p> Name Type Description <code>func</code> <code>SolverCallable</code> <p>Original solver function</p> <code>jitted_func</code> <code>SolverCallable</code> <p>JIT-compiled solver function</p> <code>name</code> <code>str</code> <p>Solver identifier</p> Source code in <code>src/attractors/solvers/registry.py</code> <pre><code>@dataclass\nclass Solver:\n    \"\"\"\n    Data class representing a numerical ODE solver with JIT compilation support.\n\n    Attributes:\n        func (SolverCallable): Original solver function\n        jitted_func (SolverCallable): JIT-compiled solver function\n        name (str): Solver identifier\n    \"\"\"\n\n    func: SolverCallable\n    jitted_func: SolverCallable\n    name: str\n\n    def get_func(self, jitted: bool = True) -&gt; SolverCallable:\n        \"\"\"\n        Get solver function.\n\n        Args:\n            jitted (bool, optional): Whether to return JIT-compiled version. Defaults to True.\n\n        Returns:\n            SolverCallable: Solver function (JIT-compiled or original)\n        \"\"\"\n        return self.jitted_func if jitted else self.func\n\n    def __repr__(self) -&gt; str:\n        return f\"Solver(name={self.name})\"\n</code></pre>"},{"location":"api/#attractors.Solver.get_func","title":"<code>attractors.Solver.get_func(jitted=True)</code>","text":"<p>Get solver function.</p> <p>Parameters:</p> Name Type Description Default <code>jitted</code> <code>bool</code> <p>Whether to return JIT-compiled version. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>SolverCallable</code> <code>SolverCallable</code> <p>Solver function (JIT-compiled or original)</p> Source code in <code>src/attractors/solvers/registry.py</code> <pre><code>def get_func(self, jitted: bool = True) -&gt; SolverCallable:\n    \"\"\"\n    Get solver function.\n\n    Args:\n        jitted (bool, optional): Whether to return JIT-compiled version. Defaults to True.\n\n    Returns:\n        SolverCallable: Solver function (JIT-compiled or original)\n    \"\"\"\n    return self.jitted_func if jitted else self.func\n</code></pre>"},{"location":"api/#attractors.SolverRegistry","title":"<code>attractors.SolverRegistry</code>","text":"<p>Registry for numerical ODE solvers with JIT compilation support.</p> Each solver must be registered with a unique name and follow the interface <ul> <li>Input: (system_func, state, params, dt)</li> <li>Output: next state vector</li> </ul> <p>Solvers are automatically JIT-compiled during registration.</p> <p>Attributes:</p> Name Type Description <code>_solvers</code> <code>dict[str, Solver]</code> <p>Internal dict mapping solver names to Solver instances</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @SolverRegistry.register(\"rk4\")\n&gt;&gt;&gt; def rk4(system_func, state, params, dt):\n...     # RK4 implementation\n...     return next_state\n</code></pre> <pre><code>&gt;&gt;&gt; solver = SolverRegistry.get(\"rk4\")\n</code></pre> Source code in <code>src/attractors/solvers/registry.py</code> <pre><code>class SolverRegistry:\n    \"\"\"\n    Registry for numerical ODE solvers with JIT compilation support.\n\n    Each solver must be registered with a unique name and follow the interface:\n        - Input: (system_func, state, params, dt)\n        - Output: next state vector\n\n    Solvers are automatically JIT-compiled during registration.\n\n    Attributes:\n        _solvers: Internal dict mapping solver names to Solver instances\n\n    Examples:\n        &gt;&gt;&gt; @SolverRegistry.register(\"rk4\")\n        &gt;&gt;&gt; def rk4(system_func, state, params, dt):\n        ...     # RK4 implementation\n        ...     return next_state\n\n        &gt;&gt;&gt; solver = SolverRegistry.get(\"rk4\")\n    \"\"\"\n\n    _solvers: ClassVar[dict[str, Solver]] = {}\n\n    @classmethod\n    def register(cls, name: str) -&gt; Callable[[F], F]:\n        \"\"\"Register a solver function in the SolverRegistry.\n\n        Decorator that registers a solver function and creates a JIT-compiled version.\n        The registered solver must take (system_func, state, params, dt) arguments and\n        return the next state vector.\n\n        Args:\n            name (str): Unique identifier for the solver\n\n        Returns:\n            Callable[[F], F]: Decorator function that registers and JIT-compiles the solver\n\n        Raises:\n            TypeError: If name is not a string or decorated object is not callable\n            ValueError: If solver name is already registered\n\n        Examples:\n            &gt;&gt;&gt; @SolverRegistry.register(\"solver_name\")\n            &gt;&gt;&gt; def custom_solver(system_func, state, params, dt):\n            ...     # Solver implementation\n            ...     return next_state\n        \"\"\"\n\n        def decorator(f: F) -&gt; F:\n            if not isinstance(name, str):\n                raise TypeError(\"Name must be string\")\n            if not callable(f):\n                raise TypeError(\"Must register callable\")\n            if name in cls._solvers:\n                msg = f\"Solver {name} already registered\"\n                raise ValueError(msg)\n\n            jitted_f = njit(f)\n            cls._solvers[name] = Solver(f, jitted_f, name)\n            return f\n\n        logger.debug(\"Registered solver: %s\", name)\n        return decorator\n\n    @classmethod\n    def get(cls, name: str) -&gt; Solver:\n        \"\"\"\n        Retrieve a registered solver by name\n\n        Args:\n            name (str): Name of solver to retrieve\n\n        Raises:\n            KeyError: If solver name not found\n\n        Returns:\n            Solver: Registered Solver instance\n        \"\"\"\n        if name not in cls._solvers:\n            msg = f\"Solver {name} not found\"\n            raise KeyError(msg)\n        logger.debug(\"Getting solver: %s\", name)\n        return cls._solvers[name]\n\n    @classmethod\n    def list_solvers(cls) -&gt; list[str]:\n        \"\"\"\n        Get list of all registered solver names.\n\n        Returns:\n            list[str]: List of solver names\n        \"\"\"\n        return list(cls._solvers.keys())\n\n    @staticmethod\n    def is_jitted(func: Callable[..., Any]) -&gt; bool:\n        \"\"\"\n        Check if a function is JIT-compiled.\n\n        Args:\n            func (Callable[..., Any]): Function to check\n\n        Returns:\n            bool: True if function is JIT-compiled\n        \"\"\"\n        return isinstance(func, Dispatcher)\n</code></pre>"},{"location":"api/#attractors.SolverRegistry.register","title":"<code>attractors.SolverRegistry.register(name)</code>  <code>classmethod</code>","text":"<p>Register a solver function in the SolverRegistry.</p> <p>Decorator that registers a solver function and creates a JIT-compiled version. The registered solver must take (system_func, state, params, dt) arguments and return the next state vector.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the solver</p> required <p>Returns:</p> Type Description <code>Callable[[F], F]</code> <p>Callable[[F], F]: Decorator function that registers and JIT-compiles the solver</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If name is not a string or decorated object is not callable</p> <code>ValueError</code> <p>If solver name is already registered</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @SolverRegistry.register(\"solver_name\")\n&gt;&gt;&gt; def custom_solver(system_func, state, params, dt):\n...     # Solver implementation\n...     return next_state\n</code></pre> Source code in <code>src/attractors/solvers/registry.py</code> <pre><code>@classmethod\ndef register(cls, name: str) -&gt; Callable[[F], F]:\n    \"\"\"Register a solver function in the SolverRegistry.\n\n    Decorator that registers a solver function and creates a JIT-compiled version.\n    The registered solver must take (system_func, state, params, dt) arguments and\n    return the next state vector.\n\n    Args:\n        name (str): Unique identifier for the solver\n\n    Returns:\n        Callable[[F], F]: Decorator function that registers and JIT-compiles the solver\n\n    Raises:\n        TypeError: If name is not a string or decorated object is not callable\n        ValueError: If solver name is already registered\n\n    Examples:\n        &gt;&gt;&gt; @SolverRegistry.register(\"solver_name\")\n        &gt;&gt;&gt; def custom_solver(system_func, state, params, dt):\n        ...     # Solver implementation\n        ...     return next_state\n    \"\"\"\n\n    def decorator(f: F) -&gt; F:\n        if not isinstance(name, str):\n            raise TypeError(\"Name must be string\")\n        if not callable(f):\n            raise TypeError(\"Must register callable\")\n        if name in cls._solvers:\n            msg = f\"Solver {name} already registered\"\n            raise ValueError(msg)\n\n        jitted_f = njit(f)\n        cls._solvers[name] = Solver(f, jitted_f, name)\n        return f\n\n    logger.debug(\"Registered solver: %s\", name)\n    return decorator\n</code></pre>"},{"location":"api/#attractors.SolverRegistry.get","title":"<code>attractors.SolverRegistry.get(name)</code>  <code>classmethod</code>","text":"<p>Retrieve a registered solver by name</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of solver to retrieve</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If solver name not found</p> <p>Returns:</p> Name Type Description <code>Solver</code> <code>Solver</code> <p>Registered Solver instance</p> Source code in <code>src/attractors/solvers/registry.py</code> <pre><code>@classmethod\ndef get(cls, name: str) -&gt; Solver:\n    \"\"\"\n    Retrieve a registered solver by name\n\n    Args:\n        name (str): Name of solver to retrieve\n\n    Raises:\n        KeyError: If solver name not found\n\n    Returns:\n        Solver: Registered Solver instance\n    \"\"\"\n    if name not in cls._solvers:\n        msg = f\"Solver {name} not found\"\n        raise KeyError(msg)\n    logger.debug(\"Getting solver: %s\", name)\n    return cls._solvers[name]\n</code></pre>"},{"location":"api/#attractors.SolverRegistry.list_solvers","title":"<code>attractors.SolverRegistry.list_solvers()</code>  <code>classmethod</code>","text":"<p>Get list of all registered solver names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of solver names</p> Source code in <code>src/attractors/solvers/registry.py</code> <pre><code>@classmethod\ndef list_solvers(cls) -&gt; list[str]:\n    \"\"\"\n    Get list of all registered solver names.\n\n    Returns:\n        list[str]: List of solver names\n    \"\"\"\n    return list(cls._solvers.keys())\n</code></pre>"},{"location":"api/#attractors.SolverRegistry.is_jitted","title":"<code>attractors.SolverRegistry.is_jitted(func)</code>  <code>staticmethod</code>","text":"<p>Check if a function is JIT-compiled.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>Function to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if function is JIT-compiled</p> Source code in <code>src/attractors/solvers/registry.py</code> <pre><code>@staticmethod\ndef is_jitted(func: Callable[..., Any]) -&gt; bool:\n    \"\"\"\n    Check if a function is JIT-compiled.\n\n    Args:\n        func (Callable[..., Any]): Function to check\n\n    Returns:\n        bool: True if function is JIT-compiled\n    \"\"\"\n    return isinstance(func, Dispatcher)\n</code></pre>"},{"location":"api/#attractors.System","title":"<code>attractors.System</code>  <code>dataclass</code>","text":"<p>Data class representing a dynamical system with JIT compilation support.</p> <p>Attributes:</p> Name Type Description <code>func</code> <code>SystemCallable</code> <p>Original system function</p> <code>jitted_func</code> <code>SystemCallable</code> <p>JIT-compiled system function</p> <code>name</code> <code>str</code> <p>System identifier</p> <code>params</code> <code>Vector</code> <p>System parameters vector</p> <code>param_names</code> <code>list[str]</code> <p>List of parameter names</p> <code>reference</code> <code>str</code> <p>Academic reference</p> <code>init_coord</code> <code>Vector</code> <p>Initial state vector</p> <code>plot_lims</code> <code>PlotLimits | None</code> <p>Optional plotting limits</p> Source code in <code>src/attractors/systems/registry.py</code> <pre><code>@dataclass\nclass System:\n    \"\"\"\n    Data class representing a dynamical system with JIT compilation support.\n\n    Attributes:\n        func (SystemCallable): Original system function\n        jitted_func (SystemCallable): JIT-compiled system function\n        name (str): System identifier\n        params (Vector): System parameters vector\n        param_names (list[str]): List of parameter names\n        reference (str): Academic reference\n        init_coord (Vector): Initial state vector\n        plot_lims (PlotLimits | None): Optional plotting limits\n    \"\"\"\n\n    func: SystemCallable\n    jitted_func: SystemCallable\n    name: str\n    params: Vector\n    param_names: list[str]\n    reference: str\n    init_coord: Vector\n    plot_lims: PlotLimits | None = None\n\n    def set_params(self, params: Vector) -&gt; None:\n        \"\"\"\n        Set system parameters.\n\n        Args:\n            params (Vector): New parameter vector\n\n        Raises:\n            ValueError: If parameter count doesn't match expected number of parameters\n        \"\"\"\n        if len(params) != len(self.param_names):\n            msg = f\"Expected {len(self.param_names)} parameters\"\n            raise ValueError(msg)\n        logger.debug(\"Setting parameters: %s for system: %s\", params, self.name)\n        self.params = params\n\n    def set_init_coord(self, coord: Vector) -&gt; None:\n        \"\"\"\n        Set initial state coordinates.\n\n        Args:\n            coord (Vector): Initial state vector (must have length 3)\n\n        Raises:\n            ValueError: If coordinate vector length is not 3\n        \"\"\"\n        if len(coord) != 3:\n            raise ValueError(\"State vector must have length 3\")\n        logger.debug(\"Setting initial coord: %s for system: %s\", coord, self.name)\n        self.init_coord = coord\n\n    def get_func(self, jitted: bool = True) -&gt; SystemCallable:\n        \"\"\"\n        Get system function.\n\n        Args:\n            jitted (bool, optional): Whether to return JIT-compiled version. Defaults to True.\n\n        Returns:\n            SystemCallable: System function (JIT-compiled or original)\n        \"\"\"\n        return self.jitted_func if jitted else self.func\n</code></pre>"},{"location":"api/#attractors.System.set_params","title":"<code>attractors.System.set_params(params)</code>","text":"<p>Set system parameters.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Vector</code> <p>New parameter vector</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If parameter count doesn't match expected number of parameters</p> Source code in <code>src/attractors/systems/registry.py</code> <pre><code>def set_params(self, params: Vector) -&gt; None:\n    \"\"\"\n    Set system parameters.\n\n    Args:\n        params (Vector): New parameter vector\n\n    Raises:\n        ValueError: If parameter count doesn't match expected number of parameters\n    \"\"\"\n    if len(params) != len(self.param_names):\n        msg = f\"Expected {len(self.param_names)} parameters\"\n        raise ValueError(msg)\n    logger.debug(\"Setting parameters: %s for system: %s\", params, self.name)\n    self.params = params\n</code></pre>"},{"location":"api/#attractors.System.set_init_coord","title":"<code>attractors.System.set_init_coord(coord)</code>","text":"<p>Set initial state coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coord</code> <code>Vector</code> <p>Initial state vector (must have length 3)</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If coordinate vector length is not 3</p> Source code in <code>src/attractors/systems/registry.py</code> <pre><code>def set_init_coord(self, coord: Vector) -&gt; None:\n    \"\"\"\n    Set initial state coordinates.\n\n    Args:\n        coord (Vector): Initial state vector (must have length 3)\n\n    Raises:\n        ValueError: If coordinate vector length is not 3\n    \"\"\"\n    if len(coord) != 3:\n        raise ValueError(\"State vector must have length 3\")\n    logger.debug(\"Setting initial coord: %s for system: %s\", coord, self.name)\n    self.init_coord = coord\n</code></pre>"},{"location":"api/#attractors.System.get_func","title":"<code>attractors.System.get_func(jitted=True)</code>","text":"<p>Get system function.</p> <p>Parameters:</p> Name Type Description Default <code>jitted</code> <code>bool</code> <p>Whether to return JIT-compiled version. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>SystemCallable</code> <code>SystemCallable</code> <p>System function (JIT-compiled or original)</p> Source code in <code>src/attractors/systems/registry.py</code> <pre><code>def get_func(self, jitted: bool = True) -&gt; SystemCallable:\n    \"\"\"\n    Get system function.\n\n    Args:\n        jitted (bool, optional): Whether to return JIT-compiled version. Defaults to True.\n\n    Returns:\n        SystemCallable: System function (JIT-compiled or original)\n    \"\"\"\n    return self.jitted_func if jitted else self.func\n</code></pre>"},{"location":"api/#attractors.SystemRegistry","title":"<code>attractors.SystemRegistry</code>","text":"<p>Registry for dynamical systems with JIT compilation support.</p> Each system must be registered with <ul> <li>Unique name</li> <li>Default parameters and their names</li> <li>Initial coordinates</li> <li>Optional plotting limits and academic reference</li> </ul> <p>Systems are automatically JIT-compiled during registration.</p> <p>Attributes:</p> Name Type Description <code>_systems</code> <code>dict[str, System]</code> <p>Internal dict mapping system names to System instances</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @SystemRegistry.register(\n...     \"lorenz\",\n...     default_params=np.array([10.0, 28.0, 8 / 3]),\n...     param_names=[\"sigma\", \"rho\", \"beta\"],\n...     init_coord=np.array([0.0, 1.0, 0.0]),\n... )\n... def lorenz(state: Vector, params: Vector) -&gt; Vector:\n...     x, y, z = state\n...     sigma, rho, beta = params\n...     return np.array([sigma * (y - x), x * (rho - z) - y, x * y - beta * z])\n</code></pre> Source code in <code>src/attractors/systems/registry.py</code> <pre><code>class SystemRegistry:\n    \"\"\"\n    Registry for dynamical systems with JIT compilation support.\n\n    Each system must be registered with:\n        - Unique name\n        - Default parameters and their names\n        - Initial coordinates\n        - Optional plotting limits and academic reference\n\n    Systems are automatically JIT-compiled during registration.\n\n    Attributes:\n        _systems: Internal dict mapping system names to System instances\n\n    Examples:\n        &gt;&gt;&gt; @SystemRegistry.register(\n        ...     \"lorenz\",\n        ...     default_params=np.array([10.0, 28.0, 8 / 3]),\n        ...     param_names=[\"sigma\", \"rho\", \"beta\"],\n        ...     init_coord=np.array([0.0, 1.0, 0.0]),\n        ... )\n        ... def lorenz(state: Vector, params: Vector) -&gt; Vector:\n        ...     x, y, z = state\n        ...     sigma, rho, beta = params\n        ...     return np.array([sigma * (y - x), x * (rho - z) - y, x * y - beta * z])\n    \"\"\"\n\n    _systems: ClassVar[dict[str, System]] = {}\n\n    @classmethod\n    def register(\n        cls,\n        name: str,\n        *,\n        default_params: Vector,\n        param_names: list[str],\n        reference: str = \"\",\n        init_coord: Vector,\n        plot_lims: PlotLimits | None = None,\n    ) -&gt; Callable[[F], F]:\n        \"\"\"\n        Register a system function in the SystemRegistry.\n\n        Decorator that registers a system function and creates a JIT-compiled version.\n        The registered system must take (state, params) Vector type arguments and\n        return the next state vector.\n\n        Args:\n            name (str): Unique identifier for the system\n            default_params (Vector): Default parameter values\n            param_names (list[str]): Names of parameters\n            reference (str, optional): Academic reference. Defaults to \"\".\n            init_coord (Vector): Initial state vector\n            plot_lims (PlotLimits | None, optional): Plotting limits. Defaults to None.\n\n        Returns:\n            Callable[[F], F]: Decorator function that registers and JIT-compiles the system\n\n        Raises:\n            TypeError: If name is not a string or decorated object is not callable\n            ValueError: If system name is already registered\n\n        Examples:\n            &gt;&gt;&gt; @SystemRegistry.register(\"lorenz\")\n            ... def lorenz(state: Vector, params: Vector) -&gt; Vector:\n            ...     x, y, z = state\n            ...     sigma, rho, beta = params\n            ...     return np.array([sigma * (y - x), x * (rho - z) - y, x * y - beta * z])\n        \"\"\"\n\n        def decorator(f: F) -&gt; F:\n            if not isinstance(name, str):\n                raise TypeError(\"Name must be string\")\n            if not callable(f):\n                raise TypeError(\"Must register callable\")\n            if name in cls._systems:\n                msg = f\"System {name} already registered\"\n                raise ValueError(msg)\n\n            jitted_f = f if cls.is_jitted(f) else njit(f)\n            cls._systems[name] = System(\n                func=f,\n                jitted_func=jitted_f,\n                name=name,\n                params=default_params,\n                param_names=param_names,\n                reference=reference,\n                init_coord=init_coord,\n                plot_lims=plot_lims,\n            )\n            return f\n\n        logger.debug(\"Registered system: %s\", name)\n        return decorator\n\n    @classmethod\n    def get(cls, name: str) -&gt; System:\n        \"\"\"\n        Get registered system by name.\n\n        Args:\n            name (str): Name of system to retrieve\n\n        Returns:\n            System: Registered System instance\n\n        Raises:\n            KeyError: If system name is not found\n        \"\"\"\n        if name not in cls._systems:\n            msg = f\"System {name} not found\"\n            raise KeyError(msg)\n        logger.debug(\"Getting system: %s\", name)\n        return cls._systems[name]\n\n    @classmethod\n    def list_systems(cls) -&gt; list[str]:\n        \"\"\"\n        Get list of all registered system names.\n\n        Returns:\n            list[str]: List of registered system names\n        \"\"\"\n        return list(cls._systems.keys())\n\n    @staticmethod\n    def is_jitted(func: Callable[..., Any]) -&gt; bool:\n        \"\"\"\n        Check if a function is JIT-compiled.\n\n        Args:\n            func (Callable[..., Any]): Function to check\n\n        Returns:\n            bool: True if function is JIT-compiled\n        \"\"\"\n        return isinstance(func, Dispatcher)\n</code></pre>"},{"location":"api/#attractors.SystemRegistry.register","title":"<code>attractors.SystemRegistry.register(name, *, default_params, param_names, reference='', init_coord, plot_lims=None)</code>  <code>classmethod</code>","text":"<p>Register a system function in the SystemRegistry.</p> <p>Decorator that registers a system function and creates a JIT-compiled version. The registered system must take (state, params) Vector type arguments and return the next state vector.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the system</p> required <code>default_params</code> <code>Vector</code> <p>Default parameter values</p> required <code>param_names</code> <code>list[str]</code> <p>Names of parameters</p> required <code>reference</code> <code>str</code> <p>Academic reference. Defaults to \"\".</p> <code>''</code> <code>init_coord</code> <code>Vector</code> <p>Initial state vector</p> required <code>plot_lims</code> <code>PlotLimits | None</code> <p>Plotting limits. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[F], F]</code> <p>Callable[[F], F]: Decorator function that registers and JIT-compiles the system</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If name is not a string or decorated object is not callable</p> <code>ValueError</code> <p>If system name is already registered</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @SystemRegistry.register(\"lorenz\")\n... def lorenz(state: Vector, params: Vector) -&gt; Vector:\n...     x, y, z = state\n...     sigma, rho, beta = params\n...     return np.array([sigma * (y - x), x * (rho - z) - y, x * y - beta * z])\n</code></pre> Source code in <code>src/attractors/systems/registry.py</code> <pre><code>@classmethod\ndef register(\n    cls,\n    name: str,\n    *,\n    default_params: Vector,\n    param_names: list[str],\n    reference: str = \"\",\n    init_coord: Vector,\n    plot_lims: PlotLimits | None = None,\n) -&gt; Callable[[F], F]:\n    \"\"\"\n    Register a system function in the SystemRegistry.\n\n    Decorator that registers a system function and creates a JIT-compiled version.\n    The registered system must take (state, params) Vector type arguments and\n    return the next state vector.\n\n    Args:\n        name (str): Unique identifier for the system\n        default_params (Vector): Default parameter values\n        param_names (list[str]): Names of parameters\n        reference (str, optional): Academic reference. Defaults to \"\".\n        init_coord (Vector): Initial state vector\n        plot_lims (PlotLimits | None, optional): Plotting limits. Defaults to None.\n\n    Returns:\n        Callable[[F], F]: Decorator function that registers and JIT-compiles the system\n\n    Raises:\n        TypeError: If name is not a string or decorated object is not callable\n        ValueError: If system name is already registered\n\n    Examples:\n        &gt;&gt;&gt; @SystemRegistry.register(\"lorenz\")\n        ... def lorenz(state: Vector, params: Vector) -&gt; Vector:\n        ...     x, y, z = state\n        ...     sigma, rho, beta = params\n        ...     return np.array([sigma * (y - x), x * (rho - z) - y, x * y - beta * z])\n    \"\"\"\n\n    def decorator(f: F) -&gt; F:\n        if not isinstance(name, str):\n            raise TypeError(\"Name must be string\")\n        if not callable(f):\n            raise TypeError(\"Must register callable\")\n        if name in cls._systems:\n            msg = f\"System {name} already registered\"\n            raise ValueError(msg)\n\n        jitted_f = f if cls.is_jitted(f) else njit(f)\n        cls._systems[name] = System(\n            func=f,\n            jitted_func=jitted_f,\n            name=name,\n            params=default_params,\n            param_names=param_names,\n            reference=reference,\n            init_coord=init_coord,\n            plot_lims=plot_lims,\n        )\n        return f\n\n    logger.debug(\"Registered system: %s\", name)\n    return decorator\n</code></pre>"},{"location":"api/#attractors.SystemRegistry.get","title":"<code>attractors.SystemRegistry.get(name)</code>  <code>classmethod</code>","text":"<p>Get registered system by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of system to retrieve</p> required <p>Returns:</p> Name Type Description <code>System</code> <code>System</code> <p>Registered System instance</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If system name is not found</p> Source code in <code>src/attractors/systems/registry.py</code> <pre><code>@classmethod\ndef get(cls, name: str) -&gt; System:\n    \"\"\"\n    Get registered system by name.\n\n    Args:\n        name (str): Name of system to retrieve\n\n    Returns:\n        System: Registered System instance\n\n    Raises:\n        KeyError: If system name is not found\n    \"\"\"\n    if name not in cls._systems:\n        msg = f\"System {name} not found\"\n        raise KeyError(msg)\n    logger.debug(\"Getting system: %s\", name)\n    return cls._systems[name]\n</code></pre>"},{"location":"api/#attractors.SystemRegistry.list_systems","title":"<code>attractors.SystemRegistry.list_systems()</code>  <code>classmethod</code>","text":"<p>Get list of all registered system names.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of registered system names</p> Source code in <code>src/attractors/systems/registry.py</code> <pre><code>@classmethod\ndef list_systems(cls) -&gt; list[str]:\n    \"\"\"\n    Get list of all registered system names.\n\n    Returns:\n        list[str]: List of registered system names\n    \"\"\"\n    return list(cls._systems.keys())\n</code></pre>"},{"location":"api/#attractors.SystemRegistry.is_jitted","title":"<code>attractors.SystemRegistry.is_jitted(func)</code>  <code>staticmethod</code>","text":"<p>Check if a function is JIT-compiled.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>Function to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if function is JIT-compiled</p> Source code in <code>src/attractors/systems/registry.py</code> <pre><code>@staticmethod\ndef is_jitted(func: Callable[..., Any]) -&gt; bool:\n    \"\"\"\n    Check if a function is JIT-compiled.\n\n    Args:\n        func (Callable[..., Any]): Function to check\n\n    Returns:\n        bool: True if function is JIT-compiled\n    \"\"\"\n    return isinstance(func, Dispatcher)\n</code></pre>"},{"location":"api/#attractors.ThemeManager","title":"<code>attractors.ThemeManager</code>","text":"<p>Manager for loading and accessing visualization themes.</p> <p>Themes can be loaded from JSON files, added/removed programmatically, and accessed by name or randomly. A default theme is always available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ThemeManager.load(\"themes.json\")\n&gt;&gt;&gt; theme = ThemeManager.get(\"dark\")\n&gt;&gt;&gt; ThemeManager.set_default(\"light\")\n&gt;&gt;&gt; random_theme = ThemeManager.random()\n</code></pre> Source code in <code>src/attractors/themes/manager.py</code> <pre><code>class ThemeManager:\n    \"\"\"\n    Manager for loading and accessing visualization themes.\n\n    Themes can be loaded from JSON files, added/removed programmatically,\n    and accessed by name or randomly. A default theme is always available.\n\n    Examples:\n        &gt;&gt;&gt; ThemeManager.load(\"themes.json\")\n        &gt;&gt;&gt; theme = ThemeManager.get(\"dark\")\n        &gt;&gt;&gt; ThemeManager.set_default(\"light\")\n        &gt;&gt;&gt; random_theme = ThemeManager.random()\n    \"\"\"\n\n    _themes: ClassVar[dict[str, Theme]] = {}\n    _default_theme: ClassVar[str] = \"ayu\"\n\n    @classmethod\n    def load(cls, path: str | Path) -&gt; None:\n        \"\"\"\n        Load themes from JSON file.\n\n        Args:\n            path (str | Path): Path to JSON theme file\n        \"\"\"\n        with open(path) as f:\n            theme_data = json.load(f)\n\n        for name, data in theme_data.items():\n            cls._themes[name] = Theme(\n                name=name,\n                background=data[\"background\"],\n                colors=data[\"colors\"],\n                foreground=data.get(\"foreground\", \"#FFFFFF\"),\n            )\n\n    @classmethod\n    def get(cls, name: str | None = None) -&gt; Theme:\n        \"\"\"\n        Get theme by name or default.\n\n        Args:\n            name (str | None, optional): Theme name. Uses default if None. Defaults to None.\n\n        Returns:\n            Theme: Requested theme instance\n\n        Raises:\n            KeyError: If theme name not found\n        \"\"\"\n        name = name or cls._default_theme\n        if name not in cls._themes:\n            msg = f\"Theme '{name}' not found\"\n            raise KeyError(msg)\n        return cls._themes[name]\n\n    @classmethod\n    def list_themes(cls) -&gt; list[str]:\n        \"\"\"\n        List available themes.\n\n        Returns:\n            list[str]: List of theme names\n        \"\"\"\n        return list(cls._themes.keys())\n\n    @classmethod\n    def set_default(cls, name: str) -&gt; None:\n        \"\"\"\n        Set default theme.\n\n        Args:\n            name (str): Name of theme to set as default\n\n        Raises:\n            KeyError: If theme name not found\n        \"\"\"\n        if name not in cls._themes:\n            msg = f\"Theme '{name}' not found\"\n            raise KeyError(msg)\n        cls._default_theme = name\n\n    @classmethod\n    def add(cls, theme: Theme) -&gt; None:\n        \"\"\"\n        Add new theme.\n\n        Args:\n            theme (Theme): Theme instance to add\n        \"\"\"\n        cls._themes[theme.name] = theme\n\n    @classmethod\n    def remove(cls, name: str) -&gt; None:\n        \"\"\"\n        Remove theme.\n\n        Args:\n            name (str): Name of theme to remove\n\n        Raises:\n            ValueError: If attempting to remove default theme\n        \"\"\"\n        if name == cls._default_theme:\n            raise ValueError(\"Cannot remove default theme\")\n        cls._themes.pop(name)\n\n    @classmethod\n    def random(cls) -&gt; Theme:\n        \"\"\"\n        Get random theme.\n\n        Returns:\n            Theme: Randomly selected theme instance\n        \"\"\"\n        return random.choice(list(cls._themes.values()))  # noqa: S311\n</code></pre>"},{"location":"api/#attractors.ThemeManager.load","title":"<code>attractors.ThemeManager.load(path)</code>  <code>classmethod</code>","text":"<p>Load themes from JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to JSON theme file</p> required Source code in <code>src/attractors/themes/manager.py</code> <pre><code>@classmethod\ndef load(cls, path: str | Path) -&gt; None:\n    \"\"\"\n    Load themes from JSON file.\n\n    Args:\n        path (str | Path): Path to JSON theme file\n    \"\"\"\n    with open(path) as f:\n        theme_data = json.load(f)\n\n    for name, data in theme_data.items():\n        cls._themes[name] = Theme(\n            name=name,\n            background=data[\"background\"],\n            colors=data[\"colors\"],\n            foreground=data.get(\"foreground\", \"#FFFFFF\"),\n        )\n</code></pre>"},{"location":"api/#attractors.ThemeManager.get","title":"<code>attractors.ThemeManager.get(name=None)</code>  <code>classmethod</code>","text":"<p>Get theme by name or default.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Theme name. Uses default if None. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Theme</code> <code>Theme</code> <p>Requested theme instance</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If theme name not found</p> Source code in <code>src/attractors/themes/manager.py</code> <pre><code>@classmethod\ndef get(cls, name: str | None = None) -&gt; Theme:\n    \"\"\"\n    Get theme by name or default.\n\n    Args:\n        name (str | None, optional): Theme name. Uses default if None. Defaults to None.\n\n    Returns:\n        Theme: Requested theme instance\n\n    Raises:\n        KeyError: If theme name not found\n    \"\"\"\n    name = name or cls._default_theme\n    if name not in cls._themes:\n        msg = f\"Theme '{name}' not found\"\n        raise KeyError(msg)\n    return cls._themes[name]\n</code></pre>"},{"location":"api/#attractors.ThemeManager.list_themes","title":"<code>attractors.ThemeManager.list_themes()</code>  <code>classmethod</code>","text":"<p>List available themes.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of theme names</p> Source code in <code>src/attractors/themes/manager.py</code> <pre><code>@classmethod\ndef list_themes(cls) -&gt; list[str]:\n    \"\"\"\n    List available themes.\n\n    Returns:\n        list[str]: List of theme names\n    \"\"\"\n    return list(cls._themes.keys())\n</code></pre>"},{"location":"api/#attractors.ThemeManager.set_default","title":"<code>attractors.ThemeManager.set_default(name)</code>  <code>classmethod</code>","text":"<p>Set default theme.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of theme to set as default</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If theme name not found</p> Source code in <code>src/attractors/themes/manager.py</code> <pre><code>@classmethod\ndef set_default(cls, name: str) -&gt; None:\n    \"\"\"\n    Set default theme.\n\n    Args:\n        name (str): Name of theme to set as default\n\n    Raises:\n        KeyError: If theme name not found\n    \"\"\"\n    if name not in cls._themes:\n        msg = f\"Theme '{name}' not found\"\n        raise KeyError(msg)\n    cls._default_theme = name\n</code></pre>"},{"location":"api/#attractors.ThemeManager.add","title":"<code>attractors.ThemeManager.add(theme)</code>  <code>classmethod</code>","text":"<p>Add new theme.</p> <p>Parameters:</p> Name Type Description Default <code>theme</code> <code>Theme</code> <p>Theme instance to add</p> required Source code in <code>src/attractors/themes/manager.py</code> <pre><code>@classmethod\ndef add(cls, theme: Theme) -&gt; None:\n    \"\"\"\n    Add new theme.\n\n    Args:\n        theme (Theme): Theme instance to add\n    \"\"\"\n    cls._themes[theme.name] = theme\n</code></pre>"},{"location":"api/#attractors.ThemeManager.remove","title":"<code>attractors.ThemeManager.remove(name)</code>  <code>classmethod</code>","text":"<p>Remove theme.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of theme to remove</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If attempting to remove default theme</p> Source code in <code>src/attractors/themes/manager.py</code> <pre><code>@classmethod\ndef remove(cls, name: str) -&gt; None:\n    \"\"\"\n    Remove theme.\n\n    Args:\n        name (str): Name of theme to remove\n\n    Raises:\n        ValueError: If attempting to remove default theme\n    \"\"\"\n    if name == cls._default_theme:\n        raise ValueError(\"Cannot remove default theme\")\n    cls._themes.pop(name)\n</code></pre>"},{"location":"api/#attractors.ThemeManager.random","title":"<code>attractors.ThemeManager.random()</code>  <code>classmethod</code>","text":"<p>Get random theme.</p> <p>Returns:</p> Name Type Description <code>Theme</code> <code>Theme</code> <p>Randomly selected theme instance</p> Source code in <code>src/attractors/themes/manager.py</code> <pre><code>@classmethod\ndef random(cls) -&gt; Theme:\n    \"\"\"\n    Get random theme.\n\n    Returns:\n        Theme: Randomly selected theme instance\n    \"\"\"\n    return random.choice(list(cls._themes.values()))  # noqa: S311\n</code></pre>"},{"location":"api/#attractors.Theme","title":"<code>attractors.Theme</code>  <code>dataclass</code>","text":"<p>Immutable theme data class for visualization styling.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Theme identifier</p> <code>background</code> <code>str</code> <p>Background color in hex format</p> <code>foreground</code> <code>str</code> <p>Foreground color in hex format</p> <code>colors</code> <code>str | list[str]</code> <p>Either matplotlib colormap name or list of hex colors</p> Source code in <code>src/attractors/themes/theme.py</code> <pre><code>@dataclass(frozen=True)\nclass Theme:\n    \"\"\"\n    Immutable theme data class for visualization styling.\n\n    Attributes:\n        name (str): Theme identifier\n        background (str): Background color in hex format\n        foreground (str): Foreground color in hex format\n        colors (str | list[str]): Either matplotlib colormap name or list of hex colors\n    \"\"\"\n\n    name: str\n    background: str\n    foreground: str\n    colors: str | list[str]\n\n    @property\n    def colormap(self) -&gt; matplotlib.colors.Colormap:\n        \"\"\"\n        Get matplotlib colormap for theme colors.\n\n        Returns:\n            matplotlib.colors.Colormap: Generated colormap from theme colors\n        \"\"\"\n        if isinstance(self.colors, str):\n            return matplotlib.colormaps[self.colors]\n        rgb_colors = [\n            tuple(int(c.lstrip(\"#\")[i : i + 2], 16) / 255 for i in (0, 2, 4)) for c in self.colors\n        ]\n        return matplotlib.colors.LinearSegmentedColormap.from_list(self.name, rgb_colors)\n</code></pre>"},{"location":"api/#attractors.Theme.colormap","title":"<code>attractors.Theme.colormap</code>  <code>property</code>","text":"<p>Get matplotlib colormap for theme colors.</p> <p>Returns:</p> Type Description <code>Colormap</code> <p>matplotlib.colors.Colormap: Generated colormap from theme colors</p>"},{"location":"api/#attractors.AnimatedPlotter","title":"<code>attractors.AnimatedPlotter</code>","text":"<p>               Bases: <code>BasePlotter</code></p> Source code in <code>src/attractors/visualizers/animate.py</code> <pre><code>class AnimatedPlotter(BasePlotter):\n    def visualize_impl(\n        self,\n        trajectory: Vector,\n        **kwargs: AnimatedVisualizeKwargs,\n    ) -&gt; \"AnimatedPlotter\":\n        \"\"\"\n        Create an animation showing trajectory evolution over time with\n        colored segments.\n\n        Args:\n            trajectory (Vector): Trajectory points to visualize\n            **kwargs (AnimatedVisualizeKwargs): Animation parameters. Refer to attributes of AnimatedVisualizeKwargs.\n        Returns:\n            AnimatedPlotter: Self reference for method chaining\n        \"\"\"  # noqa: E501\n        self.speed = typing.cast(int, kwargs.get(\"speed\", 20))\n        self.line_kwargs = typing.cast(dict[str, Any], kwargs.get(\"line_kwargs\", {})) or {}\n        self.anim_kwargs = typing.cast(dict[str, Any], kwargs.get(\"anim_kwargs\", {})) or {}\n        interval = typing.cast(int, kwargs.get(\"interval\", 1))\n        rotate_view = typing.cast(Callable[[Axes3D], None] | None, kwargs.get(\"rotate_view\"))\n\n        self._setup_plot()\n        segment_length = len(trajectory) // self.num_segments\n        colors = self.theme.colormap(np.linspace(0, 1, self.num_segments))\n        lines: list[Line3D] = [\n            self.ax.plot([], [], [], \"-\", c=color, **self.line_kwargs)[0] for color in colors\n        ]\n\n        def init() -&gt; list[Line3D]:\n            for line in lines:\n                line.set_data_3d([], [], [])\n            return lines\n\n        def update(frame: int) -&gt; Sequence[Line3D]:\n            frame = frame * self.speed\n            active_segments = min(frame // segment_length + 1, self.num_segments)\n\n            for i in range(self.num_segments):\n                if i &lt; active_segments:\n                    start_idx = i * segment_length\n                    end_idx = min(start_idx + segment_length, frame + 1)\n                    lines[i].set_data_3d(\n                        trajectory[start_idx:end_idx, 0],\n                        trajectory[start_idx:end_idx, 1],\n                        trajectory[start_idx:end_idx, 2],\n                    )\n\n                ax: Axes3D = self.ax\n                if rotate_view is not None:\n                    rotate_view(ax)\n\n            return lines\n\n        self.anim = animation.FuncAnimation(\n            self.fig,\n            update,\n            init_func=init,\n            frames=len(trajectory) // self.speed,\n            interval=interval,\n            **self.anim_kwargs,\n        )\n\n        return self\n</code></pre>"},{"location":"api/#attractors.AnimatedPlotter.visualize_impl","title":"<code>attractors.AnimatedPlotter.visualize_impl(trajectory, **kwargs)</code>","text":"<p>Create an animation showing trajectory evolution over time with colored segments.</p> <p>Parameters:</p> Name Type Description Default <code>trajectory</code> <code>Vector</code> <p>Trajectory points to visualize</p> required <code>**kwargs</code> <code>AnimatedVisualizeKwargs</code> <p>Animation parameters. Refer to attributes of AnimatedVisualizeKwargs.</p> <code>{}</code> <p>Returns:     AnimatedPlotter: Self reference for method chaining</p> Source code in <code>src/attractors/visualizers/animate.py</code> <pre><code>def visualize_impl(\n    self,\n    trajectory: Vector,\n    **kwargs: AnimatedVisualizeKwargs,\n) -&gt; \"AnimatedPlotter\":\n    \"\"\"\n    Create an animation showing trajectory evolution over time with\n    colored segments.\n\n    Args:\n        trajectory (Vector): Trajectory points to visualize\n        **kwargs (AnimatedVisualizeKwargs): Animation parameters. Refer to attributes of AnimatedVisualizeKwargs.\n    Returns:\n        AnimatedPlotter: Self reference for method chaining\n    \"\"\"  # noqa: E501\n    self.speed = typing.cast(int, kwargs.get(\"speed\", 20))\n    self.line_kwargs = typing.cast(dict[str, Any], kwargs.get(\"line_kwargs\", {})) or {}\n    self.anim_kwargs = typing.cast(dict[str, Any], kwargs.get(\"anim_kwargs\", {})) or {}\n    interval = typing.cast(int, kwargs.get(\"interval\", 1))\n    rotate_view = typing.cast(Callable[[Axes3D], None] | None, kwargs.get(\"rotate_view\"))\n\n    self._setup_plot()\n    segment_length = len(trajectory) // self.num_segments\n    colors = self.theme.colormap(np.linspace(0, 1, self.num_segments))\n    lines: list[Line3D] = [\n        self.ax.plot([], [], [], \"-\", c=color, **self.line_kwargs)[0] for color in colors\n    ]\n\n    def init() -&gt; list[Line3D]:\n        for line in lines:\n            line.set_data_3d([], [], [])\n        return lines\n\n    def update(frame: int) -&gt; Sequence[Line3D]:\n        frame = frame * self.speed\n        active_segments = min(frame // segment_length + 1, self.num_segments)\n\n        for i in range(self.num_segments):\n            if i &lt; active_segments:\n                start_idx = i * segment_length\n                end_idx = min(start_idx + segment_length, frame + 1)\n                lines[i].set_data_3d(\n                    trajectory[start_idx:end_idx, 0],\n                    trajectory[start_idx:end_idx, 1],\n                    trajectory[start_idx:end_idx, 2],\n                )\n\n            ax: Axes3D = self.ax\n            if rotate_view is not None:\n                rotate_view(ax)\n\n        return lines\n\n    self.anim = animation.FuncAnimation(\n        self.fig,\n        update,\n        init_func=init,\n        frames=len(trajectory) // self.speed,\n        interval=interval,\n        **self.anim_kwargs,\n    )\n\n    return self\n</code></pre>"},{"location":"api/#attractors.AnimatedVisualizeKwargs","title":"<code>attractors.AnimatedVisualizeKwargs</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Type definition for animation visualization parameters.</p> <p>Attributes:</p> Name Type Description <code>speed</code> <code>int</code> <p>Speed multiplier for animation</p> <code>interval</code> <code>int</code> <p>Animation interval in milliseconds</p> <code>rotate_view</code> <code>Callable[[Axes3D], None]</code> <p>Function to rotate view in each frame</p> <code>line_kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for matplotlib line plots</p> <code>anim_kwargs</code> <code>dict[str, Any]</code> <p>Additional arguments for matplotlib animation</p> Source code in <code>src/attractors/visualizers/animate.py</code> <pre><code>class AnimatedVisualizeKwargs(TypedDict, total=False):\n    \"\"\"\n    Type definition for animation visualization parameters.\n\n    Attributes:\n        speed (int): Speed multiplier for animation\n        interval (int): Animation interval in milliseconds\n        rotate_view (Callable[[Axes3D], None]): Function to rotate view in each frame\n        line_kwargs (dict[str, Any]): Additional arguments for matplotlib line plots\n        anim_kwargs (dict[str, Any]): Additional arguments for matplotlib animation\n    \"\"\"\n\n    speed: int\n    interval: int\n    rotate_view: Callable[[Axes3D], None] | None\n    line_kwargs: dict[str, Any] | None\n    anim_kwargs: dict[str, Any] | None\n</code></pre>"},{"location":"api/#attractors.BasePlotter","title":"<code>attractors.BasePlotter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for visualization of dynamical systems.</p> <p>An abstract base class that handles the common functionality for plotting and visualizing dynamical systems trajectories, including color mapping and plot setup.</p> <p>Attributes:</p> Name Type Description <code>VALID_COLOR_OPTIONS</code> <code>tuple[str, ...]</code> <p>Valid color mapping options (\"time\", \"x\", \"y\", \"z\", \"velocity\")</p> Source code in <code>src/attractors/visualizers/base.py</code> <pre><code>class BasePlotter(ABC):\n    \"\"\"\n    Abstract base class for visualization of dynamical systems.\n\n    An abstract base class that handles the common functionality for plotting and visualizing\n    dynamical systems trajectories, including color mapping and plot setup.\n\n    Attributes:\n        VALID_COLOR_OPTIONS (tuple[str, ...]): Valid color mapping options (\"time\", \"x\", \"y\", \"z\", \"velocity\")\n    \"\"\"  # noqa: E501\n\n    VALID_COLOR_OPTIONS = (\"time\", \"x\", \"y\", \"z\", \"velocity\")\n\n    def __init__(\n        self,\n        system: System,\n        theme: Theme,\n        num_segments: int = 50,\n        color_by: str | ColorMapper = \"time\",\n        color_cycles: float = 1.0,\n        fig_kwargs: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the plotter.\n\n        Args:\n            system (System): Dynamical system to visualize\n            theme (Theme): Visual theme for plots\n            num_segments (int): Number of segments for visualization\n            color_by (str | ColorMapper): Color mapping strategy (\"time\", \"x\", \"y\", \"z\", \"velocity\") or ColorMapper instance\n            color_cycles (float): Number of color cycles through the palette\n            fig_kwargs (dict[str, Any] | None): Additional arguments for matplotlib figure\n\n        Raises:\n            ValueError: If color_by is not a valid option or ColorMapper instance\n        \"\"\"  # noqa: E501\n        self.color_mapper: ColorMapper\n        self.system = system\n        self.theme = theme\n        self.num_segments = num_segments\n        self.color_cycles = color_cycles\n        self.fig_kwargs = fig_kwargs or {}\n\n        if isinstance(color_by, str):\n            if color_by not in self.VALID_COLOR_OPTIONS:\n                msg = f\"color_by must be one of {self.VALID_COLOR_OPTIONS} or a ColorMapper\"\n                raise ValueError(msg)\n\n            if color_by == \"time\":\n                self.color_mapper = TimeColorMapper()\n            elif color_by == \"velocity\":\n                self.color_mapper = VelocityColorMapper()\n            else:  # x, y, z\n                self.color_mapper = CoordinateColorMapper({\"x\": 0, \"y\": 1, \"z\": 2}[color_by])\n        else:\n            self.color_mapper = color_by\n\n    def _validate_inputs(\n        self, num_segments: int, color_cycles: float, color_by: str | Callable[[Vector], Vector]\n    ) -&gt; None:\n        \"\"\"\n        Validate initialization parameters.\n\n        Args:\n            num_segments (int): Number of segments for visualization\n            color_cycles (float): Number of color cycles through the palette\n            color_by (str | Callable[[Vector], Vector]): Color mapping strategy\n\n        Raises:\n            ValueError: If parameters are invalid\n        \"\"\"\n        if num_segments &lt;= 0:\n            raise ValueError(\"num_segments must be positive\")\n        if color_cycles &lt;= 0:\n            raise ValueError(\"color_cycles must be positive\")\n        if isinstance(color_by, str) and color_by not in self.VALID_COLOR_OPTIONS:\n            error_message = f\"color_by must be one of {self.VALID_COLOR_OPTIONS} or a callable\"\n            raise ValueError(error_message)\n\n    def _setup_plot(self) -&gt; None:\n        \"\"\"Configure matplotlib figure and 3D axes with theme settings.\"\"\"\n        self.fig = plt.figure(facecolor=self.theme.background, **self.fig_kwargs)\n        self.ax = self.fig.add_subplot(111, projection=\"3d\")\n        self.ax.set_facecolor(self.theme.background)\n        self.ax.set_axis_off()\n\n        for axis in [\"x\", \"y\", \"z\"]:\n            if self.system.plot_lims:\n                getattr(self.ax, f\"set_{axis}lim\")(*self.system.plot_lims[f\"{axis}lim\"])  # type: ignore[literal-required]\n\n    def _get_color_values(self, trajectory: Vector) -&gt; Vector:\n        \"\"\"\n        Map trajectory points to color values.\n\n        Args:\n            trajectory (Vector): Trajectory points to map to colors\n\n        Returns:\n            Color values for each trajectory point\n\n        Raises:\n            ValueError: If color mapping fails\n        \"\"\"\n        try:\n            values = self.color_mapper.map(trajectory)\n            return (values * self.color_cycles) % 1.0\n        except Exception as e:\n            msg = f\"Error in color mapping: {e!s}\"\n            raise ValueError(msg) from e\n\n    def visualize(\n        self,\n        trajectory: Vector,\n        compression: float = 0.0,\n        compression_method: CompressionMethod = CompressionMethod.VELOCITY,\n        **kwargs: Any,\n    ) -&gt; \"BasePlotter\":\n        \"\"\"\n        Process and visualize trajectory data.\n\n        Args:\n            trajectory (Vector): Trajectory points to visualize\n            compression (float): Compression ratio (0.0 to 1.0)\n            compression_method (CompressionMethod): Method for trajectory compression\n            **kwargs (Any): Additional visualization parameters\n\n        Returns:\n            BasePlotter: Self reference for method chaining\n        \"\"\"\n        processed = _downsample_trajectory(trajectory, compression, compression_method)\n        return self.visualize_impl(processed, **kwargs)\n\n    @abstractmethod\n    def visualize_impl(self, trajectory: Vector, **kwargs: Any) -&gt; \"BasePlotter\":\n        \"\"\"Implementation specific visualization logic\"\"\"\n</code></pre>"},{"location":"api/#attractors.BasePlotter.__init__","title":"<code>attractors.BasePlotter.__init__(system, theme, num_segments=50, color_by='time', color_cycles=1.0, fig_kwargs=None)</code>","text":"<p>Initialize the plotter.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>Dynamical system to visualize</p> required <code>theme</code> <code>Theme</code> <p>Visual theme for plots</p> required <code>num_segments</code> <code>int</code> <p>Number of segments for visualization</p> <code>50</code> <code>color_by</code> <code>str | ColorMapper</code> <p>Color mapping strategy (\"time\", \"x\", \"y\", \"z\", \"velocity\") or ColorMapper instance</p> <code>'time'</code> <code>color_cycles</code> <code>float</code> <p>Number of color cycles through the palette</p> <code>1.0</code> <code>fig_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional arguments for matplotlib figure</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If color_by is not a valid option or ColorMapper instance</p> Source code in <code>src/attractors/visualizers/base.py</code> <pre><code>def __init__(\n    self,\n    system: System,\n    theme: Theme,\n    num_segments: int = 50,\n    color_by: str | ColorMapper = \"time\",\n    color_cycles: float = 1.0,\n    fig_kwargs: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the plotter.\n\n    Args:\n        system (System): Dynamical system to visualize\n        theme (Theme): Visual theme for plots\n        num_segments (int): Number of segments for visualization\n        color_by (str | ColorMapper): Color mapping strategy (\"time\", \"x\", \"y\", \"z\", \"velocity\") or ColorMapper instance\n        color_cycles (float): Number of color cycles through the palette\n        fig_kwargs (dict[str, Any] | None): Additional arguments for matplotlib figure\n\n    Raises:\n        ValueError: If color_by is not a valid option or ColorMapper instance\n    \"\"\"  # noqa: E501\n    self.color_mapper: ColorMapper\n    self.system = system\n    self.theme = theme\n    self.num_segments = num_segments\n    self.color_cycles = color_cycles\n    self.fig_kwargs = fig_kwargs or {}\n\n    if isinstance(color_by, str):\n        if color_by not in self.VALID_COLOR_OPTIONS:\n            msg = f\"color_by must be one of {self.VALID_COLOR_OPTIONS} or a ColorMapper\"\n            raise ValueError(msg)\n\n        if color_by == \"time\":\n            self.color_mapper = TimeColorMapper()\n        elif color_by == \"velocity\":\n            self.color_mapper = VelocityColorMapper()\n        else:  # x, y, z\n            self.color_mapper = CoordinateColorMapper({\"x\": 0, \"y\": 1, \"z\": 2}[color_by])\n    else:\n        self.color_mapper = color_by\n</code></pre>"},{"location":"api/#attractors.BasePlotter.visualize","title":"<code>attractors.BasePlotter.visualize(trajectory, compression=0.0, compression_method=CompressionMethod.VELOCITY, **kwargs)</code>","text":"<p>Process and visualize trajectory data.</p> <p>Parameters:</p> Name Type Description Default <code>trajectory</code> <code>Vector</code> <p>Trajectory points to visualize</p> required <code>compression</code> <code>float</code> <p>Compression ratio (0.0 to 1.0)</p> <code>0.0</code> <code>compression_method</code> <code>CompressionMethod</code> <p>Method for trajectory compression</p> <code>VELOCITY</code> <code>**kwargs</code> <code>Any</code> <p>Additional visualization parameters</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>BasePlotter</code> <code>BasePlotter</code> <p>Self reference for method chaining</p> Source code in <code>src/attractors/visualizers/base.py</code> <pre><code>def visualize(\n    self,\n    trajectory: Vector,\n    compression: float = 0.0,\n    compression_method: CompressionMethod = CompressionMethod.VELOCITY,\n    **kwargs: Any,\n) -&gt; \"BasePlotter\":\n    \"\"\"\n    Process and visualize trajectory data.\n\n    Args:\n        trajectory (Vector): Trajectory points to visualize\n        compression (float): Compression ratio (0.0 to 1.0)\n        compression_method (CompressionMethod): Method for trajectory compression\n        **kwargs (Any): Additional visualization parameters\n\n    Returns:\n        BasePlotter: Self reference for method chaining\n    \"\"\"\n    processed = _downsample_trajectory(trajectory, compression, compression_method)\n    return self.visualize_impl(processed, **kwargs)\n</code></pre>"},{"location":"api/#attractors.BasePlotter.visualize_impl","title":"<code>attractors.BasePlotter.visualize_impl(trajectory, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Implementation specific visualization logic</p> Source code in <code>src/attractors/visualizers/base.py</code> <pre><code>@abstractmethod\ndef visualize_impl(self, trajectory: Vector, **kwargs: Any) -&gt; \"BasePlotter\":\n    \"\"\"Implementation specific visualization logic\"\"\"\n</code></pre>"},{"location":"api/#attractors.StaticPlotter","title":"<code>attractors.StaticPlotter</code>","text":"<p>               Bases: <code>BasePlotter</code></p> <p>Plotter for static visualization of dynamical system trajectories.</p> Source code in <code>src/attractors/visualizers/static.py</code> <pre><code>class StaticPlotter(BasePlotter):\n    \"\"\"Plotter for static visualization of dynamical system trajectories.\"\"\"\n\n    def visualize_impl(\n        self,\n        trajectory: Vector,\n        line_kwargs: dict[str, Any] | None = None,\n        segment_overlap: int = 1,\n        **kwargs: Any,\n    ) -&gt; \"StaticPlotter\":\n        \"\"\"\n        Create a static plot of trajectory segments with color mapping.\n\n        Args:\n            trajectory (Vector): Trajectory points to visualize\n            line_kwargs (dict[str, Any] | None): Additional arguments for matplotlib line plots.\n            segment_overlap (int): Number of points to overlap between segments. Defaults to 1.\n            **kwargs (Any): Additional visualization parameters\n\n        Returns:\n            StaticPlotter: Self reference for method chaining\n        \"\"\"\n        if line_kwargs is None:\n            line_kwargs = {\"linewidth\": 1, \"antialiased\": True}\n\n        self._setup_plot()\n\n        line_kwargs = line_kwargs or {\"linewidth\": 1, \"antialiased\": True}\n\n        n = len(trajectory)\n        segment_size = n // self.num_segments\n        overlap = segment_overlap\n\n        segments = []\n        color_values = self._get_color_values(trajectory)\n        color_segments = []\n\n        for i in range(self.num_segments):\n            start_idx = max(0, i * segment_size - overlap)\n            end_idx = min(n, (i + 1) * segment_size + overlap)\n            segments.append(trajectory[start_idx:end_idx])\n            color_segments.append(color_values[start_idx:end_idx])\n\n        for segment, color_segment in zip(segments, color_segments, strict=False):\n            self.ax.plot(\n                segment[:, 0],\n                segment[:, 1],\n                segment[:, 2],\n                \"-\",\n                c=self.theme.colormap(color_segment.mean()),\n                **line_kwargs,\n            )\n        return self\n</code></pre>"},{"location":"api/#attractors.StaticPlotter.visualize_impl","title":"<code>attractors.StaticPlotter.visualize_impl(trajectory, line_kwargs=None, segment_overlap=1, **kwargs)</code>","text":"<p>Create a static plot of trajectory segments with color mapping.</p> <p>Parameters:</p> Name Type Description Default <code>trajectory</code> <code>Vector</code> <p>Trajectory points to visualize</p> required <code>line_kwargs</code> <code>dict[str, Any] | None</code> <p>Additional arguments for matplotlib line plots.</p> <code>None</code> <code>segment_overlap</code> <code>int</code> <p>Number of points to overlap between segments. Defaults to 1.</p> <code>1</code> <code>**kwargs</code> <code>Any</code> <p>Additional visualization parameters</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>StaticPlotter</code> <code>StaticPlotter</code> <p>Self reference for method chaining</p> Source code in <code>src/attractors/visualizers/static.py</code> <pre><code>def visualize_impl(\n    self,\n    trajectory: Vector,\n    line_kwargs: dict[str, Any] | None = None,\n    segment_overlap: int = 1,\n    **kwargs: Any,\n) -&gt; \"StaticPlotter\":\n    \"\"\"\n    Create a static plot of trajectory segments with color mapping.\n\n    Args:\n        trajectory (Vector): Trajectory points to visualize\n        line_kwargs (dict[str, Any] | None): Additional arguments for matplotlib line plots.\n        segment_overlap (int): Number of points to overlap between segments. Defaults to 1.\n        **kwargs (Any): Additional visualization parameters\n\n    Returns:\n        StaticPlotter: Self reference for method chaining\n    \"\"\"\n    if line_kwargs is None:\n        line_kwargs = {\"linewidth\": 1, \"antialiased\": True}\n\n    self._setup_plot()\n\n    line_kwargs = line_kwargs or {\"linewidth\": 1, \"antialiased\": True}\n\n    n = len(trajectory)\n    segment_size = n // self.num_segments\n    overlap = segment_overlap\n\n    segments = []\n    color_values = self._get_color_values(trajectory)\n    color_segments = []\n\n    for i in range(self.num_segments):\n        start_idx = max(0, i * segment_size - overlap)\n        end_idx = min(n, (i + 1) * segment_size + overlap)\n        segments.append(trajectory[start_idx:end_idx])\n        color_segments.append(color_values[start_idx:end_idx])\n\n    for segment, color_segment in zip(segments, color_segments, strict=False):\n        self.ax.plot(\n            segment[:, 0],\n            segment[:, 1],\n            segment[:, 2],\n            \"-\",\n            c=self.theme.colormap(color_segment.mean()),\n            **line_kwargs,\n        )\n    return self\n</code></pre>"},{"location":"api/#attractors.integrate_system","title":"<code>attractors.integrate_system(system, solver, steps, dt, use_jit=None)</code>","text":"<p>Integrates a dynamical system using the specified numerical solver.</p> <p>Parameters:</p> Name Type Description Default <code>system</code> <code>System</code> <p>System to integrate</p> required <code>solver</code> <code>Solver</code> <p>Numerical solver to use for integration</p> required <code>steps</code> <code>int</code> <p>Number of integration steps</p> required <code>dt</code> <code>float</code> <p>Time step size</p> required <code>use_jit</code> <code>bool | None</code> <p>Whether to use Numba JIT compilation. Defaults to True.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If steps &lt;= 0 or dt &lt;= 0</p> <p>Returns:</p> Type Description <code>tuple[Vector, Vector]</code> <p>tuple[Vector, Vector]: A tuple containing: - Vector: System state trajectory at each time step - Vector: Time points corresponding to trajectory</p> Source code in <code>src/attractors/solvers/core.py</code> <pre><code>def integrate_system(\n    system: System, solver: Solver, steps: int, dt: float, use_jit: bool | None = None\n) -&gt; tuple[Vector, Vector]:\n    \"\"\"Integrates a dynamical system using the specified numerical solver.\n\n    Args:\n        system (System): System to integrate\n        solver (Solver): Numerical solver to use for integration\n        steps (int): Number of integration steps\n        dt (float): Time step size\n        use_jit (bool | None): Whether to use Numba JIT compilation. Defaults to True.\n\n    Raises:\n        ValueError: If steps &lt;= 0 or dt &lt;= 0\n\n    Returns:\n        tuple[Vector, Vector]: A tuple containing:\n            - Vector: System state trajectory at each time step\n            - Vector: Time points corresponding to trajectory\n\n    \"\"\"\n    if steps &lt;= 0:\n        raise ValueError(\"Number of steps must be positive\")\n    if dt &lt;= 0:\n        raise ValueError(\"Time step must be positive\")\n\n    jit_enabled = True if use_jit is None else use_jit\n    logger.debug(\"JIT enabled: %s\", jit_enabled)\n    logger.info(\"Integrating system: %s with solver: %s\", system, solver)\n    logger.info(\"Steps: %d, dt: %.6g\", steps, dt)\n\n    if jit_enabled is True:\n        integrate_func = _integrate_trajectory_jitted\n    else:\n        integrate_func = _integrate_trajectory_impl\n\n    system_func = system.get_func(jit_enabled)\n    solver_func = solver.get_func(jit_enabled)\n\n    return integrate_func(  # type: ignore[no-any-return]\n        system_func, solver_func, system.init_coord, system.params, steps, dt\n    )\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#attractors-v140-140-31-jul-2021","title":"attractors v1.4.0 (1.4.0) - 31 Jul 2021","text":""},{"location":"changelog/#announcements","title":"Announcements","text":"<ul> <li>Minor release introducing documentation and added features</li> </ul>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Added 3 new attractors: Newton-Leipnik, Rucklidge and Shimizu-Morioka (Thanks @Sarath-24)</li> <li><code>index</code> is now a kwarg for <code>plot</code> methods</li> <li>Added docstrings</li> <li>Added type hints</li> <li>Set-up documentation with Sphinx-Napolean (Google Style) and ReadTheDocs</li> <li>Renamed attractors: Aizawa -&gt; Langford, Chen Celikovsky -&gt; Chen LU, Thomas Cyclically Symmetric -&gt; Thomas</li> <li>Added tests for video generation with FFMPEG and colormaps</li> </ul> <p>Changes</p> <p></p>"},{"location":"changelog/#attractors-v130-130-20-jul-2021","title":"attractors v1.3.0 (1.3.0) - 20 Jul 2021","text":""},{"location":"changelog/#announcements_1","title":"Announcements","text":"<ul> <li>Minor release with breaking changes (not backwards compatible)</li> </ul>"},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li>DES methods now return a generator instead of an <code>Attractor</code> instance</li> <li>X, Y, Z attributes of the <code>Attractor</code> are now single-valued floats instead of lists</li> <li>Modified plotting and animation methods to support generators</li> <li>Removed slice method</li> <li>(Dev) Coverage tests</li> </ul> <p>Changes</p> <p></p>"},{"location":"changelog/#attractors-v120-120-15-jul-2021","title":"attractors v1.2.0 (1.2.0) - 15 Jul 2021","text":""},{"location":"changelog/#announcements_2","title":"Announcements","text":"<ul> <li>Minor version bump adding 2 new attractors</li> </ul>"},{"location":"changelog/#changes_2","title":"Changes","text":"<ul> <li>Added 2 new attractors : Dequan Li and Yu Wang</li> <li>Removed legacy animate functions <code>animate_gradient()</code> and <code>animate_sim()</code></li> <li>Added kwargs to control gradient axis, elevation and azimuth rate.</li> <li>Added line and point kwargs to pass to matplotlib</li> <li>Tweaked default params for multiple attractors</li> <li>Minor bugfixes</li> </ul> <p>Changes</p> <p></p>"},{"location":"changelog/#attractors-v111-111-09-jul-2021","title":"attractors v1.1.1 (1.1.1) - 09 Jul 2021","text":""},{"location":"changelog/#announcements_3","title":"Announcements","text":"<ul> <li>Patch 1.1.1 for parser rewrite</li> </ul>"},{"location":"changelog/#changes_3","title":"Changes","text":"<ul> <li>parser rewrite based on Attractor class</li> <li>parametrized testing (pytest)</li> </ul> <p>Changes</p> <p></p>"},{"location":"changelog/#attractors-v110-110-07-jul-2021","title":"attractors v1.1.0 (1.1.0) - 07 Jul 2021","text":""},{"location":"changelog/#announcements_4","title":"Announcements","text":"<ul> <li>Update of attractors package with various new features and bugfixes</li> </ul>"},{"location":"changelog/#changes_4","title":"Changes","text":"<ul> <li>Completely overhauled attractor class for modularity</li> <li>Pooling update_func() for figure with pathos</li> <li>New methods for setting various params independently</li> <li>Included plotting methods</li> <li>Bugfixes and minor QoL changes</li> </ul> <p>Changes</p> <p></p>"},{"location":"changelog/#attractors-v100-100-03-jul-2021","title":"attractors v1.0.0 (1.0.0) - 03 Jul 2021","text":""},{"location":"changelog/#announcements_5","title":"Announcements","text":"<ul> <li>First major release of attractors package</li> </ul>"},{"location":"changelog/#changes_5","title":"Changes","text":"<ul> <li>Rewrite of animate functions</li> <li>New attractor module</li> <li>Live gradient plotting</li> </ul> <p>Changes</p>"},{"location":"nav/","title":"Nav","text":"<ul> <li>Home</li> <li>Quick start</li> <li>Usage guide<ul> <li>Overview</li> <li>guides/*.md</li> </ul> </li> <li>*/</li> <li>*.md</li> <li>API docs</li> <li>Changelog</li> </ul>"},{"location":"quickstart/","title":"Getting Started","text":""},{"location":"quickstart/#installation","title":"Installation","text":"<p>The simplest way to install <code>attractors</code> is via pip:</p> <pre><code>pip install attractors\n</code></pre> <p>For users who prefer modern Python packaging tools, you can also install using uv:</p> <pre><code>uv install attractors\n</code></pre>"},{"location":"quickstart/#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.11 or higher</li> <li>Primarily the package uses 3 main dependencies:</li> <li><code>numpy</code> for numerical computation</li> <li><code>numba</code> for accelerated computation</li> <li><code>matplotlib</code> for visualization</li> </ul> <p>Note</p> <p>A system must be able to compile <code>numba</code> for the package to work. If any issues arise, look at the numba installation docs.</p>"},{"location":"quickstart/#quick-start","title":"Quick Start","text":"<p>Here's a minimal example to visualize the Rossler attractor:</p> <pre><code>import matplotlib.pyplot as plt\n\nfrom attractors import SolverRegistry, StaticPlotter, SystemRegistry, ThemeManager, integrate_system\n\n# Get system and solver from registry\nsystem = SystemRegistry.get(\"rossler\")  # Using default parameters\nsolver = SolverRegistry.get(\"rk4\")  # 4th order Runge-Kutta\n\n# Generate trajectory\ntrajectory, time = integrate_system(system, solver, steps=1000000, dt=0.001)\n\n# Create visualization\ntheme = ThemeManager.random()\nplotter = StaticPlotter(system, theme)\nplotter.visualize(trajectory, line_kwargs={\"linewidth\": 1})\nplt.savefig(\"output.png\", dpi=600)\n</code></pre> <p>This script will generate a visualization of the Rossler attractor using the default parameters. Once run, you should see a plot of the attractor saved in an image file as follows:</p> <p></p> <p>Rossler attractor</p> <p>voila! You've just created your first attractor visualization! But what did we just do? For that, I recommend you to start with the user guide to understand the underlying concepts, and design principles of the package, and from there, you can not only create custom visualizations of the various systems we have with the existing solvers and themes but also create your own systems, solvers, and themes to extend the package!</p>"},{"location":"guides/overview/","title":"User Guide","text":"<p>Warning</p> <p>Documentation in progress</p> <p>The attractors package is built around four main components that work together to create beautiful visualizations of strange attractors:</p>"},{"location":"guides/overview/#systems","title":"Systems","text":"<p>Strange attractor systems are defined by their differential equations. attractors comes with 20+ pre-defined systems...</p>"},{"location":"guides/overview/#solvers","title":"Solvers","text":"<p>To generate trajectories, we need to solve the differential equations numerically. The package provides several Runge-Kutta methods...</p>"},{"location":"guides/overview/#themes","title":"Themes","text":"<p>Visual styling is handled through themes that control colors and appearance...</p>"},{"location":"guides/overview/#visualization","title":"Visualization","text":"<p>The package offers flexible options for both static plots and animations...</p>"},{"location":"guides/systems/","title":"Systems","text":"<p>Warning</p> <p>Documentation in progress</p>"}]}